#=
Applying SWAP Test on a MPS-reusable circuit to get states' overlap between 2 wave functions.
=#
export MSCpar, MScircuit, MStest, MSTtest 


"""
    MSCpar(MSCircuit::ChainBlock)
Get the set of nBit parameters from a circuit built by function `MScircuit`.
\nFields:
\n`vBit::Int64`: Number of virtual qubits.
\n`rBit::Int64`: Number of reusable qubits.
\n`nBitT::Int64`: Number of qubits in target register.
\n`nBitA::Int64`: Number of qubits(lines) in MSCircuit.
"""
struct MSCpar
    vBit::Int64  # Number of virtual qubits.
    rBit::Int64  # Number of reusable qubits.
    nBitT::Int64 # Number of qubits in target register.
    nBitA::Int64 # Number of qubits(lines) in MSCircuit.
    depth::Int64 # Depth of each MPS block in MSCircuit.
    
    function MSCpar(MSCircuit::ChainBlock)
        nBitA = nqubits(MSCircuit)
        vBit = length(MSCircuit[end-1])
        rBit = length(MSCircuit[3][2])
        nBitT = nBitA - 1 - vBit - rBit
        if length(collect_blocks(AbstractDiff, MSCircuit)) == 0
            depth = 0
        else
            depth = length(content(MSCircuit[3][1])[1])
        end
        new(vBit, rBit, nBitT, nBitA, depth)
    end
end


"""
    MScircuit(nBitT::Int64, vBit::Int64, rBit::Int64, MPSblocks::Array{CompositeBlock,1}; ϕ::Float64=0.0) -> MSCircuit::ChainBlock
Function to build quantum circuit for MPS-Swap Test.
"""
function MScircuit(nBitT::Int64, vBit::Int64, rBit::Int64, MPSblocks::Array{CompositeBlock,1}; ϕ::Float64=0.0)
    par2nd = setMPSpar(nBitT, vBit, rBit)
    nBlock = par2nd.nBlock
    nBitG = par2nd.nBit
    nBitA = 1 + nBitG + nBitT 
    Cblocks = AbstractBlock[]
    push!(Cblocks, put(nBitA, nBitA=>H))
    push!(Cblocks, put(nBitA, nBitA=>shift(ϕ)))
    for i = 1:nBlock
        MPSblock = put(nBitA, Tuple( (nBitT+1):(nBitA-1), )=>MPSblocks[i] )
        SWAPblock = chain(nBitA, [control(nBitA, nBitA, ( (nBitA-1-irBit), (nBitT-(i-1)*rBit-irBit) )=>SWAP) for irBit = 0:rBit-1])
        OpBlock = chain(nBitA, MPSblock, SWAPblock)
        push!(Cblocks, OpBlock)
        MeasureBlock = Measure(nBitA; locs=(nBitT+vBit+1):(nBitA-1), collapseto=0)
        push!(Cblocks, MeasureBlock)
    end
    SWAPvBit = chain(nBitA, [control(nBitA, nBitA, ( (nBitT+i),i )=>SWAP) for i=vBit:-1:1])
    push!(Cblocks, SWAPvBit)
    push!(Cblocks, put(nBitA, nBitA=>H))
    MSCircuit = chain(nBitA,Cblocks)
    MSCircuit
end


"""
    MStest(regT::DefaultRegister, MSCircuit::ChainBlock, vBit::Int64, rBit::Int64, nMeasure::Int64)
Main structure of MPS-Swap Test algorithm.
\nFields:
\n`reg::DefaultRegister`: The register goes through `MStest`. nqubits(MStest.reg) = 1 + vBit + rBit + nBitT.
\n`witnessOp::PutBlock`: The witness(measure) operator of the `MStest` circuit.
\n`overlap::Float64`: Overlap bewteen register generated by `MScircuit` and target register. 
"""
struct MStest
    reg::DefaultRegister # The register goes through `MStest`. nqubits(MStest.reg) = 1 + vBit + rBit + nBitT.
    witnessOp::PutBlock  # The witness(measure) operator of the `MStest` circuit.
    overlap::Float64     # Overlap bewteen register generated by MSCircuit and target register.

    function MStest(regT::DefaultRegister, MSCircuit::ChainBlock, nMeasure::Int64; useCuYao::Bool=false)
        nbset = MSCpar(MSCircuit)  
        nBitT = nqubits(regT)
        vBit = nbset.vBit
        rBit = nbset.rBit
        par2nd = setMPSpar(nBitT, vBit, rBit)
        nBlock = par2nd.nBlock
        nBitA = 1 + vBit + rBit + nBitT
        if nBitA !=nbset.nBitA || nBitT != nbset.nBitT
            print("num faut!\n")
        end
        witnessOp = put(nBitA, nBitA=>Z)
        regA = join(zero_state(1+vBit+rBit, nbatch=nMeasure), repeat(copy(regT),nMeasure) ) #This operation changes regA in the parent scope.
        useCuYao && (regA = regA |> cu)
        regA |> MSCircuit
        Overlaps = expect(witnessOp, regA)
        ActualOverlap = mean(Overlaps) |> real #Take the real part for simplicity since the imaginary part is 0.
        useCuYao && (regA = regA |> cpu)
        new(regA, witnessOp, ActualOverlap)
    end

    function MStest(regA::DefaultRegister, MSCircuit::ChainBlock)    
        nBitA = nqubits(regA)
        witnessOp = put(nBitA, nBitA=>Z)
        regA |> MSCircuit
        Overlaps = expect(witnessOp, regA)
        ActualOverlap = mean(Overlaps) |> real #Take the real part for simplicity since the imaginary part is 0.
        new(regA, witnessOp, ActualOverlap)
    end

end


"""
    MSTtest(regT::DefaultRegister, MSCircuit::ChainBlock, cExtend::ChainBlock, vBit::Int64, rBit::Int64, nMeasure::Int64)
Test function that verify the validity of MPS-Swap Test algorithm. 
\nFields:
\n`Aoverlap::Float64`: Actual overlap generated by MPS-Swap Test.
\n`Eoverlap::Float64`: Expected overlap calculated through formula.
\n`error::Float64`:    Aoverlap/Eoverlap - 1
"""
struct MSTtest
    Aoverlap::Float64 # Actual overlap generated by MPS-Swap Test.
    Eoverlap::Float64 # Expected overlap calculated through formula.
    error::Float64    # Aoverlap/Eoverlap - 1

    function MSTtest(regT::DefaultRegister, MSCircuit::ChainBlock, cExtend::ChainBlock, nMeasure::Int64)             
        MSTres = MStest(regT, MSCircuit, nMeasure)
        ActualOverlap = MSTres.overlap
        regG = zero_state(nqubits(regT))
        regG |> cExtend
        ExpectOverlap = ((regT.state'*regG.state)[1] |> abs)^2 #[1]: Convert array to complex number.
        error = ActualOverlap/ExpectOverlap - 1
        new(ActualOverlap, ExpectOverlap, error)
    end
end